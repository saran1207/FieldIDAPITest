
criteria =
{attr [!=,=,:]}rhs     only dates have comparison???

criteria {{and|or} criteria}*

rhs=bracketedValues|range|hierarchy|values

bracketedValues =
[ values ]|{ values }

values=
value{,value}*

range=value[..{.}|-]value

value=quotedValue|value

quotedValue =
" value " |
' value '


range=
location{/location}*{/}



date=
TODAY,TOMORROW,YESTERDAY,NEXTWEEK, etc... |
jan{uary},feb{ruary} etc... {[0-3]}[1-9] {ST,ND,RD,TH} COMMA, {##}## |
dashDate | slashDate

dashDate =
##-##-{##}##

slashDate =
##\/##\/{##}##



values =
xyz

xyz,abc,def
xyz,"hel-lo world*#&"

or use square brackets.
(xya,hel-lo world&%$& ,my name is derek!)
[xya,hel-lo world&%$& ,my name is derek!]


boolean values = value | !value



10-11-2011

1-9-11
02-28-2011
today,tomorrow,yesterday
*next/lastX[year,month,quarter,week]

july 1,2011
july 1
july 01,'11
july 01[st,nd,rd,th], [19|20]12
apr[il], may, jun[e] etc....

"chain sling"


attribute =
[a-z][0-9]*.
eg: color, size, height, manufacturer.


attribute=value and attribute=value or attribute=value



today...tomorrow,10-09-2011...8-6-2012,sept...october,2011...2013, july 1,2011...july 30,2012   etc...   ellipsis is two dots or three.










//    private void foo() {
//        QueryTerm term = new QueryTerm(new StringValue("people"));
//
//        // single equals value   color = blue;
//        new TermQuery(new Term(term.getAttribute(), term.getValueAsString()));
//        // list of terms. IN clause.
//
//        // x > 10, x < 10, x>=10, x<=10, x<=10.
////        NumericRangeQuery.newDoubleRange();
//
//        // x=1...100, 1 to 100
//        Double from = ((NumberValue)term.getValue().get(0)).getValue().doubleValue();
//        Double to = ((NumberValue)term.getValue().get(1)).getValue().doubleValue();
//
//
//        // x<>10  NOT
//        new TermQuery(new Term(term.getAttribute(), term.getValueAsString()));   // use MUST_NOT in boolean query. how to deal with math?
//
//        // date range.
//        // like numeric query.
//        to = ((NumberValue)term.getValue().get(1)).getValue().doubleValue();
//
//
//        // list.    how to do numeric?  is it the same?  should i create numeric range queries for all.
//        BooleanQuery booleanQuery = new BooleanQuery();
//        for (Value<?> value:term.getValue().getAllValues()) {
//            booleanQuery.add(new TermQuery(new Term(term.getAttribute(), value.getValueAsString())), BooleanClause.Occur.SHOULD);
//        }
//
//
//        // e.g. color=blue man=ford,toyota size=1...100 when=today...tomorrow identified>march 1,2014 height<54 width<>99 or foo=bar
//        BooleanQuery query = new BooleanQuery();
// SINGLE QUERY
//        query.add(new TermQuery(new Term("color","blue")), BooleanClause.Occur.MUST);
//
// LISTVALUES
//        BooleanQuery subQuery = new BooleanQuery();
//        subQuery.add(new TermQuery(new Term("man","ford")), BooleanClause.Occur.SHOULD);
//        subQuery.add(new TermQuery(new Term("man","toyota")), BooleanClause.Occur.SHOULD);
//        query.add(subQuery, BooleanClause.Occur.MUST);
//
// RANGEVALUES
//        query.add(NumericRangeQuery.newDoubleRange("size", 1.0, 100.0, true, true), BooleanClause.Occur.MUST);
// DATERANGEVALUE
//        query.add(NumericRangeQuery.newDoubleRange("when", (double)LocalDate.now().toDate().getTime(), (double)LocalDate.now().plusDays(1).toDate().getTime(), true, true), BooleanClause.Occur.MUST);
//
//        LocalDate mar1 = new LocalDate().withMonthOfYear(3).withDayOfMonth(1).withYear(2014);
//        query.add(NumericRangeQuery.newDoubleRange("identified", (double)mar1.toDate().getTime(), null, false, true ), BooleanClause.Occur.MUST);
// RANGEVALUE numeric
//        query.add(NumericRangeQuery.newDoubleRange("height", null, 54.0, true, false ), BooleanClause.Occur.MUST);
// NOTEQUALS
//        // could i change this to a simple term query??
//        query.add(NumericRangeQuery.newDoubleRange("width", 54.0, 54.0, true, true), BooleanClause.Occur.MUST_NOT);
//
// OR'd TERMS
//        query.add(new TermQuery(new Term("foo","bar")), Boolean.Clause.Occur.SHOULD);
//
//    }




















































